$date
	Mon Jun 12 16:11:54 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module gmii_test $end
$scope module transmit $end
$scope module encapsulation $end
$var wire 8 ! GMII_d [7:0] $end
$var wire 2 " bf_out_buffer_ready [1:0] $end
$var wire 1 # clk $end
$var wire 8 $ crc_data_in [7:0] $end
$var wire 1 % eth_tx_clk $end
$var wire 1 & eth_tx_en $end
$var wire 8 ' ff_out_data_in [7:0] $end
$var wire 1 ( rst $end
$var wire 1 ) data_out_en $end
$var wire 32 * crc_check [31:0] $end
$var reg 1 + GMII_tx_dv $end
$var reg 1 , GMII_tx_er $end
$var reg 1 - bf_in_pct_txed $end
$var reg 1 . bf_in_r_en $end
$var reg 16 / byte_count [15:0] $end
$var reg 1 0 crc_lsb $end
$var reg 32 1 crc_res [31:0] $end
$var reg 8 2 data_out [7:0] $end
$var reg 5 3 intr_pct_gap [4:0] $end
$var reg 16 4 len_payload [15:0] $end
$var reg 1 5 rst_crc $end
$var reg 4 6 state_reg [3:0] $end
$var reg 1 7 updatecrc $end
$scope function reflect_byte $end
$upscope $end
$scope module crc_mod $end
$var wire 1 % clk $end
$var wire 1 0 crc_lsb $end
$var wire 8 8 data [7:0] $end
$var wire 1 5 rst $end
$var wire 1 9 strt $end
$var wire 1 7 updatecrc $end
$var wire 32 : result [31:0] $end
$var wire 8 ; data_r [7:0] $end
$var reg 12 < bit_n [11:0] $end
$var reg 12 = byte_count [11:0] $end
$var reg 32 > crc [31:0] $end
$var reg 32 ? crc_acc [31:0] $end
$var reg 32 @ crc_acc_n [31:0] $end
$var reg 8 A data_buf [7:0] $end
$var reg 32 B nresult [31:0] $end
$var reg 12 C payload_len [11:0] $end
$scope function crc_bit_updt $end
$upscope $end
$scope function reflect_byte $end
$upscope $end
$scope function reflectcrc $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 D \data_regs[0] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 E \data_regs[1] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 F \data_regs[2] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 G \data_regs[3] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 H \data_regs[4] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 I \data_regs[5] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 J \data_regs[6] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 K \data_regs[7] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$scope module transmit $end
$var wire 1 L bf_in_pct_qued $end
$var wire 8 M data_in [7:0] $end
$var wire 1 ( eth_rst $end
$var wire 1 % eth_tx_clk $end
$var wire 1 & eth_tx_en $end
$var wire 1 N fifo_nrst $end
$var wire 1 O pct_qued $end
$var wire 1 P r_clk $end
$var wire 1 # sys_clk $end
$var wire 1 Q w_clk $end
$var wire 1 R w_en $end
$var wire 8 S buf_data_out [7:0] $end
$var wire 2 T bf_out_buffer_ready [1:0] $end
$var wire 1 . bf_in_r_en $end
$var wire 1 - bf_in_pct_txed $end
$scope module async_fifo $end
$var wire 1 N arst_n $end
$var wire 8 U data_in [7:0] $end
$var wire 1 V full $end
$var wire 1 P rclk $end
$var wire 1 R w_en $end
$var wire 1 # wclk $end
$var wire 13 W wrt_ptr [12:0] $end
$var wire 1 X wr_srstn $end
$var wire 13 Y read_ptr [12:0] $end
$var wire 1 Z rd_srstn $end
$var wire 1 . r_en $end
$var wire 1 [ full_gen $end
$var wire 1 \ empt $end
$var wire 8 ] data_out [7:0] $end
$scope module async_bram $end
$var wire 8 ^ data_in [7:0] $end
$var wire 1 V full $end
$var wire 1 P rd_clk $end
$var wire 1 # wr_clk $end
$var wire 1 R wr_en $end
$var wire 13 _ wrt_ptr [12:0] $end
$var wire 1 X wr_srstn $end
$var wire 12 ` w_ptr [11:0] $end
$var wire 13 a read_ptr [12:0] $end
$var wire 1 . rd_en $end
$var wire 12 b r_ptr [11:0] $end
$var wire 8 c data_out [7:0] $end
$scope begin $ivl_for_loop2 $end
$var integer 32 d i [31:0] $end
$upscope $end
$upscope $end
$scope module empt_gen $end
$var wire 13 e wr_pointer [12:0] $end
$var wire 13 f rd_pointer [12:0] $end
$var wire 1 [ full $end
$var wire 1 \ empty $end
$upscope $end
$scope module rd_pointer $end
$var wire 1 \ empty $end
$var wire 1 P rclk $end
$var wire 1 g rd_ready $end
$var wire 1 Z rd_srstn $end
$var wire 1 . rd_en $end
$var reg 13 h read_ptr [12:0] $end
$upscope $end
$scope module rd_rst_scnch_m $end
$var wire 1 P clk $end
$var wire 1 N n_as_signal $end
$var reg 1 i hold $end
$var reg 1 Z n_s_signal $end
$upscope $end
$scope module wr_pointer $end
$var wire 1 V full $end
$var wire 1 # wclk $end
$var wire 1 R wr_en $end
$var wire 1 j wr_ready $end
$var wire 1 X wr_srstn $end
$var reg 13 k wrt_ptr [12:0] $end
$upscope $end
$scope module wr_rst_scnch_m $end
$var wire 1 # clk $end
$var wire 1 N n_as_signal $end
$var reg 1 l hold $end
$var reg 1 X n_s_signal $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 m i [31:0] $end
$upscope $end
$upscope $end
$scope module buf_ready $end
$var wire 1 L bf_in_pct_qued $end
$var wire 1 % eth_tx_clk $end
$var wire 1 ( rst $end
$var wire 1 - bf_in_pct_txed $end
$var reg 2 n bf_out_buffer_ready [1:0] $end
$upscope $end
$scope module encapsulation $end
$scope function reflect_byte $end
$upscope $end
$scope module crc_mod $end
$scope function crc_bit_updt $end
$upscope $end
$scope function reflect_byte $end
$upscope $end
$scope function reflectcrc $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module gmii_test $end
$var wire 1 o adr_err $end
$var wire 2 p bf_out_buffer_ready [1:0] $end
$var wire 1 q buffer_full $end
$var wire 8 r data_in [7:0] $end
$var wire 1 s eth_rst $end
$var wire 1 % eth_rx_clk $end
$var wire 1 t eth_tx_clk $end
$var wire 1 & eth_tx_en $end
$var wire 8 u ff_out_data_in [7:0] $end
$var wire 1 v len_err $end
$var wire 1 w ncrc_err $end
$var wire 1 O pct_qued $end
$var wire 1 ( rst $end
$var wire 1 # sys_clk $end
$var reg 8 x GMII_tx_d [7:0] $end
$var reg 1 y GMII_tx_dv $end
$var reg 1 z GMII_tx_er $end
$var reg 1 { bf_in_r_en $end
$scope module decapsulation $end
$var wire 1 % clk $end
$var wire 1 | crc_lsb $end
$var wire 1 } eth_tx_clk $end
$var wire 8 ~ gmii_data_in [7:0] $end
$var wire 1 y gmii_dv $end
$var wire 1 !" gmii_en $end
$var wire 1 z gmii_er $end
$var wire 1 "" rst $end
$var wire 1 #" rst_crc $end
$var wire 1 $" updatecrc $end
$var wire 1 %" wrong_addr $end
$var wire 1 &" data_out_en $end
$var wire 32 '" crc_check [31:0] $end
$var wire 1 (" cont_stages $end
$var reg 1 )" adr_err $end
$var reg 1 *" buffer_full $end
$var reg 14 +" byte_count [13:0] $end
$var reg 80 ," data_buf [79:0] $end
$var reg 32 -" data_crc [31:0] $end
$var reg 16 ." data_len [15:0] $end
$var reg 48 /" dest_addr [47:0] $end
$var reg 8 0" gmii_buf [7:0] $end
$var reg 1 1" len_err $end
$var reg 16 2" len_payload [15:0] $end
$var reg 1 3" ncrc_err $end
$var reg 1 4" rst_crc_reg $end
$var reg 48 5" source_addr [47:0] $end
$var reg 4 6" state_reg [3:0] $end
$var reg 1 7" updatecrc_reg $end
$scope module crc_mod $end
$var wire 1 } clk $end
$var wire 1 | crc_lsb $end
$var wire 8 8" data [7:0] $end
$var wire 1 #" rst $end
$var wire 1 9" strt $end
$var wire 1 $" updatecrc $end
$var wire 32 :" result [31:0] $end
$var wire 8 ;" data_r [7:0] $end
$var reg 12 <" bit_n [11:0] $end
$var reg 12 =" byte_count [11:0] $end
$var reg 32 >" crc [31:0] $end
$var reg 32 ?" crc_acc [31:0] $end
$var reg 32 @" crc_acc_n [31:0] $end
$var reg 8 A" data_buf [7:0] $end
$var reg 32 B" nresult [31:0] $end
$var reg 12 C" payload_len [11:0] $end
$scope function crc_bit_updt $end
$upscope $end
$scope function reflect_byte $end
$upscope $end
$scope function reflectcrc $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$scope begin $ivl_for_loop2 $end
$upscope $end
$upscope $end
$scope module empt_gen $end
$upscope $end
$scope module rd_pointer $end
$upscope $end
$scope module rd_rst_scnch_m $end
$upscope $end
$scope module wr_pointer $end
$upscope $end
$scope module wr_rst_scnch_m $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$upscope $end
$upscope $end
$scope module buf_ready $end
$upscope $end
$scope module encapsulation $end
$scope function reflect_byte $end
$upscope $end
$scope module crc_mod $end
$scope function crc_bit_updt $end
$upscope $end
$scope function reflect_byte $end
$upscope $end
$scope function reflectcrc $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10111101011 C"
b0 B"
b0 A"
b11111111111111111111111111111111 @"
b11111111111111111111111111111111 ?"
b100110000010001110110110111 >"
b0 ="
b0 <"
bz0000000 ;"
b0 :"
z9"
b0z 8"
07"
b0 6"
bx 5"
14"
x3"
b0 2"
x1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
b0 +"
x*"
x)"
x("
b0 '"
1&"
0%"
0$"
1#"
z""
1!"
bx ~
z}
z|
x{
xz
xy
bx x
zw
zv
bz u
1t
zs
bz r
zq
bz p
zo
b0 n
b1000 m
0l
bx k
xj
0i
bx h
xg
bx f
bx e
b0 d
bx c
bx b
bx a
bx `
bx _
bz ^
bx ]
x\
x[
xZ
bx Y
xX
bx W
xV
bz U
b0 T
bx S
zR
1Q
1P
0O
zN
bz M
zL
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
b10111101011 C
b0 B
b0 A
b11111111111111111111111111111111 @
b11111111111111111111111111111111 ?
b100110000010001110110110111 >
b0 =
b0 <
b0 ;
b0 :
z9
b0 8
07
b0 6
15
b0 4
b0 3
b0 2
b1111 1
00
b0 /
x.
x-
x,
0+
b0 *
0)
z(
bx '
z&
1%
b0 $
1#
b0 "
b0 !
$end
#1000
0Q
0#
#2000
1Q
1#
0t
#3000
0Q
0#
0P
0%
#4000
1Q
1#
1t
#5000
0Q
0#
#6000
1Q
1#
0t
1P
1%
#7000
0Q
0#
#8000
1Q
1#
1t
#9000
0Q
0#
0P
0%
#10000
0g
0j
1i
0Z
1l
0X
0N
1Q
1#
0t
1(
#11000
0Q
0#
#12000
0V
0[
b0 '
b0 S
b0 ]
b0 c
1\
b0 b
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
0-
b0 Y
b0 a
b0 f
b0 h
b0 `
b101111101100 d
b0 W
b0 _
b0 e
b0 k
1Q
1#
1t
1P
1%
#13000
0Q
0#
#14000
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b101111101100 d
1Q
1#
0t
#15000
0Q
0#
0P
0%
#16000
1N
0(
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b101111101100 d
1Q
1#
1t
#17000
0Q
0#
#18000
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
0l
0i
b101111101100 d
1Q
1#
0t
1P
1%
#19000
0Q
0#
#20000
xj
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
1X
b101111101100 d
1Q
1#
1t
#21000
0Q
0#
0P
0%
#22000
1Q
1#
0t
#23000
0Q
0#
#24000
1Z
1Q
1#
1t
1P
1%
#25000
0Q
0#
#26000
1Q
1#
0t
#27000
0Q
0#
0P
0%
#28000
b110001 M
b110001 U
b110001 ^
b110001 r
1Q
1#
1t
#29000
0Q
0#
#30000
1Q
1#
0t
1P
1%
#31000
0Q
0#
#32000
b110010 M
b110010 U
b110010 ^
b110010 r
1Q
1#
1t
#33000
0Q
0#
0P
0%
#34000
1Q
1#
0t
#35000
0Q
0#
#36000
b110011 M
b110011 U
b110011 ^
b110011 r
1Q
1#
1t
1P
1%
#37000
0Q
0#
#38000
1Q
1#
0t
#39000
0Q
0#
0P
0%
#40000
b110100 M
b110100 U
b110100 ^
b110100 r
1Q
1#
1t
#41000
0Q
0#
#42000
1Q
1#
0t
1P
1%
#43000
0Q
0#
#44000
b110101 M
b110101 U
b110101 ^
b110101 r
1Q
1#
1t
#45000
0Q
0#
0P
0%
#46000
1Q
1#
0t
#47000
0Q
0#
#48000
b110110 M
b110110 U
b110110 ^
b110110 r
1Q
1#
1t
1P
1%
#49000
0Q
0#
#50000
1Q
1#
0t
#51000
0Q
0#
0P
0%
#52000
b110111 M
b110111 U
b110111 ^
b110111 r
1Q
1#
1t
#53000
0Q
0#
#54000
1Q
1#
0t
1P
1%
#55000
0Q
0#
#56000
b111000 M
b111000 U
b111000 ^
b111000 r
1Q
1#
1t
#57000
0Q
0#
0P
0%
#58000
1Q
1#
0t
#59000
0Q
0#
#60000
1O
b111001 M
b111001 U
b111001 ^
b111001 r
1Q
1#
1t
1P
1%
#61000
0Q
0#
#62000
1Q
1#
0t
#63000
0Q
0#
0P
0%
#64000
0O
1Q
1#
1t
#65000
0Q
0#
#66000
1Q
1#
0t
1P
1%
#67000
0Q
0#
#68000
1Q
1#
1t
#69000
0Q
0#
0P
0%
#70000
1Q
1#
0t
#71000
0Q
0#
#72000
1Q
1#
1t
1P
1%
#73000
0Q
0#
#74000
1Q
1#
0t
#75000
0Q
0#
0P
0%
#76001
