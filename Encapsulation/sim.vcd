$date
	Fri Apr 28 16:52:48 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module transmit $end
$scope module encapsulation $end
$scope module crc_mod $end
$var wire 1 ! clk $end
$var wire 8 " data [7:0] $end
$var wire 32 # result [31:0] $end
$var wire 1 $ rst $end
$var wire 1 % strt $end
$var wire 1 & updatecrc $end
$var reg 12 ' bit_n [11:0] $end
$var reg 12 ( byte_count [11:0] $end
$var reg 32 ) crc [31:0] $end
$var reg 32 * crc_acc [31:0] $end
$var reg 32 + crc_acc_n [31:0] $end
$var reg 8 , data_buf [7:0] $end
$var reg 32 - nresult [31:0] $end
$var reg 12 . payload_len [11:0] $end
$scope function crc_bit_updt $end
$upscope $end
$scope function reflect_byte $end
$upscope $end
$scope function reflectcrc $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module encapsulation $end
$var wire 1 / buffer_ready $end
$var wire 1 ! clk $end
$var wire 8 0 crc_data_in [7:0] $end
$var wire 8 1 data_in [7:0] $end
$var wire 1 2 eth_tx_clk $end
$var wire 1 3 eth_tx_en $end
$var wire 1 4 rst $end
$var wire 1 5 data_out_en $end
$var wire 32 6 crc_check [31:0] $end
$var reg 1 7 buffer_data_valid $end
$var reg 14 8 byte_count [13:0] $end
$var reg 32 9 crc_res [31:0] $end
$var reg 400 : data_buf [399:0] $end
$var reg 8 ; data_out [7:0] $end
$var reg 16 < len_payload [15:0] $end
$var reg 1 $ rst_crc $end
$var reg 1 = save_payload_buf $end
$var reg 4 > state_reg [3:0] $end
$var reg 1 & updatecrc $end
$scope module crc_mod $end
$scope function crc_bit_updt $end
$upscope $end
$scope function reflect_byte $end
$upscope $end
$scope function reflectcrc $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$var wire 1 ? arst_n $end
$var wire 8 @ data_in [7:0] $end
$var wire 1 A full $end
$var wire 1 B r_en $end
$var wire 1 2 rclk $end
$var wire 1 C w_en $end
$var wire 1 ! wclk $end
$var wire 5 D wrt_ptr [4:0] $end
$var wire 1 E wr_srstn $end
$var wire 5 F read_ptr [4:0] $end
$var wire 1 G rd_srstn $end
$var wire 1 H full_gen $end
$var wire 1 I empt $end
$var wire 8 J data_out [7:0] $end
$scope module async_bram $end
$var wire 8 K data_in [7:0] $end
$var wire 1 A full $end
$var wire 1 2 rd_clk $end
$var wire 1 B rd_en $end
$var wire 1 ! wr_clk $end
$var wire 1 C wr_en $end
$var wire 5 L wrt_ptr [4:0] $end
$var wire 4 M w_ptr [3:0] $end
$var wire 5 N read_ptr [4:0] $end
$var wire 4 O r_ptr [3:0] $end
$var reg 8 P data_out [7:0] $end
$upscope $end
$scope module empt_gen $end
$var wire 5 Q wr_pointer [4:0] $end
$var wire 5 R rd_pointer [4:0] $end
$var wire 1 H full $end
$var wire 1 I empty $end
$upscope $end
$scope module rd_pointer $end
$var wire 1 I empty $end
$var wire 1 2 rclk $end
$var wire 1 B rd_en $end
$var wire 1 S rd_ready $end
$var wire 1 G rd_srstn $end
$var reg 5 T read_ptr [4:0] $end
$upscope $end
$scope module rd_rst_scnch_m $end
$var wire 1 2 clk $end
$var wire 1 ? n_asignal $end
$var reg 1 G n_ssignal $end
$var reg 1 U toggle $end
$upscope $end
$scope module wr_pointer $end
$var wire 1 A full $end
$var wire 1 ! wclk $end
$var wire 1 C wr_en $end
$var wire 1 V wr_ready $end
$var wire 1 E wr_srstn $end
$var reg 5 W wrt_ptr [4:0] $end
$upscope $end
$scope module wr_rst_scnch_m $end
$var wire 1 ! clk $end
$var wire 1 ? n_asignal $end
$var reg 1 E n_ssignal $end
$var reg 1 X toggle $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 Y i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 Z \data_regs[0] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 [ \data_regs[1] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 \ \data_regs[2] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 ] \data_regs[3] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 ^ \data_regs[4] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 _ \data_regs[5] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$scope module async_fifo $end
$scope module async_bram $end
$var reg 8 ` \data_regs[6] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module transmit $end
$var wire 1 / buffer_ready $end
$var wire 8 a data_in [7:0] $end
$var wire 1 b eth_rst $end
$var wire 1 2 eth_tx_clk $end
$var wire 1 3 eth_tx_en $end
$var wire 1 ? fifo_nrst $end
$var wire 1 B r_en $end
$var wire 1 4 rst $end
$var wire 1 ! sys_clk $end
$var wire 1 C w_en $end
$var wire 8 c buf_data_out [7:0] $end
$scope module async_fifo $end
$scope module async_bram $end
$upscope $end
$scope module empt_gen $end
$upscope $end
$scope module rd_pointer $end
$upscope $end
$scope module rd_rst_scnch_m $end
$upscope $end
$scope module wr_pointer $end
$upscope $end
$scope module wr_rst_scnch_m $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$upscope $end
$upscope $end
$scope module encapsulation $end
$scope module crc_mod $end
$scope function crc_bit_updt $end
$upscope $end
$scope function reflect_byte $end
$upscope $end
$scope function reflectcrc $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx c
zb
bz a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
b111 Y
1X
bx W
xV
1U
bx T
xS
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bz K
bx J
xI
xH
xG
bx F
1E
bx D
zC
zB
xA
bz @
z?
b0 >
0=
b0 <
b0 ;
bx :
b1111 9
b0 8
07
b0 6
05
z4
z3
z2
bx 1
b0 0
z/
bx .
b0 -
b0 ,
b11111111111111111111111111111111 +
b11111111111111111111111111111111 *
b100110000010001110110110111 )
b0 (
b0 '
0&
z%
1$
b0 #
b0 "
1!
$end
#2000
0!
#4000
1!
#6000
0!
#8000
1!
#10000
0X
b0 1
b0 J
b0 P
b0 c
1G
0U
0?
0!
12
14
#12000
0V
0E
b0 :
1!
#14001
